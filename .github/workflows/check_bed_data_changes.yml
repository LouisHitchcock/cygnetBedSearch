name: Check Bed Data Changes

# Schedule to run daily at 10:05 AM (UTC time)
on:
  schedule:
    - cron: '5 10 * * *'  # Adjust the time as needed
  workflow_dispatch:  # Allows manual triggering of the workflow

jobs:
  check_changes:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: pip install pandas

      - name: Run data check and send email
        env:
          SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          RECIPIENT_EMAIL: ${{ secrets.RECIPIENT_EMAIL }}
        run: |
          python - <<EOF
          import pandas as pd
          import smtplib
          from email.mime.multipart import MIMEMultipart
          from email.mime.text import MIMEText
          import os

          # File paths for current and previous day data
          file_path = 'scraper/bed_data.csv'
          previous_file_path = 'scraper/bed_data_previous.csv'

          # Adjusted list of specific locations to check
          locations_to_check = [
              'Cygnet Hospital Bury',
              'Cygnet Hospital Clifton',
              'Gledholt Mews and Coach House'
          ]

          # Function to send email notification
          def send_email_notification(changes):
              smtp_server = os.getenv('SMTP_SERVER')
              smtp_port = int(os.getenv('SMTP_PORT', 587))
              smtp_user = os.getenv('SMTP_USER')
              smtp_password = os.getenv('SMTP_PASSWORD')

              from_email = smtp_user
              to_email = os.getenv('RECIPIENT_EMAIL')
              subject = 'Bed Data Changes Detected'
              body = f"Changes detected in bed data for the following locations:\n\n{changes}"

              msg = MIMEMultipart()
              msg['From'] = from_email
              msg['To'] = to_email
              msg['Subject'] = subject
              msg.attach(MIMEText(body, 'plain'))

              try:
                  server = smtplib.SMTP(smtp_server, smtp_port)
                  server.starttls()
                  server.login(smtp_user, smtp_password)
                  server.send_message(msg)
                  server.quit()
                  print("Email sent successfully.")
              except Exception as e:
                  print(f"Failed to send email: {e}")

          # Load current day's data
          print("Loading current day's data...")
          try:
              current_data = pd.read_csv(file_path)
              print("Current data loaded successfully.")
              print(current_data.head())
          except Exception as e:
              print(f"Failed to load current data: {e}")
              exit(1)

          # Check if there is a previous day's data
          if os.path.exists(previous_file_path):
              print("Loading previous day's data...")
              try:
                  previous_data = pd.read_csv(previous_file_path)
                  if previous_data.empty:
                      print("Previous data file is empty. Initializing with current data.")
                      previous_data = current_data.copy()  # Initialize with current data if empty
                      previous_data.to_csv(previous_file_path, index=False)
                  else:
                      print("Previous data loaded successfully.")
                      print(previous_data.head())
              except Exception as e:
                  print(f"Failed to load previous data: {e}")
                  print("Initializing previous data with current data.")
                  previous_data = current_data.copy()
                  previous_data.to_csv(previous_file_path, index=False)
          else:
              print("Previous day's data not found. Initializing with current data.")
              previous_data = current_data.copy()
              previous_data.to_csv(previous_file_path, index=False)

          # Merge and compare using the correct column name 'Name'
          print("Merging current and previous data...")
          try:
              # Change the merge key from 'Location' to 'Name'
              merged_data = pd.merge(current_data, previous_data, on='Name', suffixes=('_current', '_previous'))
              print("Data merged successfully.")
              print(merged_data.head())
          except Exception as e:
              print(f"Failed to merge data: {e}")
              exit(1)

          changes_detected = []

          # Iterate over the specific locations of interest
          for location in locations_to_check:
              location_data = merged_data[merged_data['Name'].str.contains(location)]
              if not location_data.empty:
                  print(f"Checking changes for {location}...")
                  if not location_data.iloc[:, 1:].equals(location_data.iloc[:, len(current_data.columns[1:]):]):
                      print(f"Changes detected for {location}.")
                      changes_detected.append(location)

          if changes_detected:
              changes_message = "\n".join(changes_detected)
              print("Changes detected. Sending email notification...")
              send_email_notification(changes_message)
          else:
              print("No changes detected.")

          # Save the current data as previous data for the next run
          try:
              current_data.to_csv(previous_file_path, index=False)
              print("Current data saved as previous data for the next run.")
          except Exception as e:
              print(f"Failed to save current data as previous: {e}")
              exit(1)
          EOF
